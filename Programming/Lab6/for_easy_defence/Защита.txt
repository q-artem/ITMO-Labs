1) Сериализация: 
	+) Преобразование объекта класса в поток байтов для последующей передачи между компонентами 
	системы или хранения. Обратный процесс называется десериализация.
	+) Интерфейс Serialazible:
		Для сериализации объекта класса он должен реализовывать интерфейс Serialazible.	
		Этот интерфейс не содержит методов а служит маркером
	+) Модификтор transient:
		Во время сериализации все поля объекта так же сериализуются, однако порой необходимо исключить 
		часть полей, для этого и нужен модификатор transient. При сериализации значение этого поля будет
		равно значению по умолчанию для своего типа данных.
	+) Объектный граф:
		При сериализации так же рекурсивно сериализуются все поля объекта, так получается объектный граф. И поэтому
		все поля являющиеся объектами должны быть ли transient, либо реализовывать Serialazible.
	+) Используется в read\writeObject, objectInputStream, ObjectOutputStream.
----------------------------------------------------------------------------------------------------------------------------
2) Сетевое взаимодействие:
	+) Сетевое взаимодествие осуществляется с помощью протоколов, которые обеспечивают передачу данных между сервером и клиентом,
	определяя правила и формат этого самого взаимодествия.
	+) Основные протоколы:
		*) TCP (Transmission Control Protocol) - обеспечивает надежную и упорядоченную доствку данных. 
		Он использует механизмы контроля ошибок и подтверждения получения данных. 
		Если пакет данных потерян или повреждён, TCP автоматически отправляет его заново.
		Использует socket, serverSocket для клиенто-серверного взаимодествия:
			*)`Socket` представляет сокет, который является точкой установления соединения между клиентом и сервером. 
			С помощью класса `Socket` можно установить клиентское соединение с сервером и обмениваться данными.
			Работает только в блокирующем режиме и может взаимодестовать только с java.io.
			Один клиент на один поток.
			*)`SokcetChannel` - надстройка над `Socket`. Работает как в блокирующем так и неблокирующем режиме. Может обрабатывать много клинетов с помощью селекторов.
			Может работать с потоками из  java.nio
			*)`ServerSocket` представляет серверный сокет, который прослушивает определенный порт и ожидает входящих клиентских подключений. 
			Как только клиентское соединение установлено, сервер создает экземпляр класса `Socket` для обмена данными с клиентом. 
			Работает только в блокирующем режиме.
			*)`ServerSocketChannel` - надстройка над `ServerSocket`. Работает как в блокирующем так и неблокирующем режиме. Может обрабатывать много клинетов с помощью селекторов.
		*) UDP (User Datagramm protocol) - обеспечивает быструю и безусловную доставку специальных пакетов данных(датаграмм).
		Однако он не устанавлиает соединение и не грантирует доставки данных в порядке их отправки, целосности данных.
		Если датаграммы не была доставлена UDP не отправит ее опять.
		Использует `DatagramSocket` и `DatagramPacket` для клиенто-серверного взаимодествия:
			*)`DatagramSocket` представляет сокет UDP и предоставляет возможность отправки и приема датаграмм. 
			Он может быть использован как для клиентской, так и для серверной стороны
			Работает только в блокирующем режиме и может взаимодестовать только с java.io.
			Один клиент на один поток.
			*)`DatagramPacket` представляет датаграмму, которая содержит информацию, 
			отправляемую или принимаемую через `DatagramSocket`. Он содержит данные, адрес назначения и порт.
			*)`DatagramChannel` - надстройка над `DatagramSocket`.
			Работа как в  блокирующем режиме так и в неблокирующем,  может взаимодестовать  с java.nio.
			Поддерживает множественную обраточку клинетов с помощью селекторов.
		*) HTTP (HypetText Transfer Protocol) - используется для передачи гипертекстовых(электронный текст, который связан ссылками с другими документами) документов в Интернете
		Он основан на протоколе TCP и использует запросы и ответы между клиентом и сервером для передачи данных.
   		В Java протокол HTTP реализуется с использованием классов  `HttpURLConnection` и `HttpClient`  
--------------------------------------------------------------------------------------------------------------------------------------------------
3) Блокирующий и неблокирующий режимы:
	*)Неблокирующий сетевой обмен (Non-blocking Network I/O) в Java можно реализовать с помощью неблокирующих 
	каналов (Non-blocking Channels) и селекторов (Selectors) из пакета `java.nio`.
	Неблокирующий сетевой обмен позволяет выполнять асинхронные операции ввода-вывода без блокирования потока исполнения. 
	Это особенно полезно при работе с большим количеством сокетов, когда блокировка каждого потока на операции ввода-вывода 
	может привести к затратам на создание и управление большим количеством потоков.
	Селекторы позволяют мониторить несколько неблокирующих каналов и определять, на каких из них доступны операции ввода-вывода. 
	Селектор следит за состоянием каждого канала и сообщает только о готовности к чтению, записи или установке соединения.
	+)Плюсы неблокирующего режима:
		Один поток — множество соединений. Экономия ресурсов.
		Высокая производительность под нагрузкой (например, 10k+ соединений).
		Гибкость (можно комбинировать TCP/UDP в одном потоке).

	-)Минусы:
		Сложнее в реализации (работа с Selector, ByteBuffer)
		Нужно обрабатывать частичные данные (т. к. read()/write() могут выполниться не полностью).
	*)Блокирующий сетевой обмен  (BIO — Blocking I/O). При вызове методов (например, accept(), read(), receive()) поток останавливается (блокируется), пока операция не завершится.
	Пример: сервер ждёт подключения клиента, и поток «засыпает» до тех пор, пока клиент не подключится.
	+) Плюсы блокирующего режима:
		Простота — код линейный и понятный.
		Хорошо подходит для простых приложений с малым числом соединений.
	-)Минусы:
		Один поток — одно соединение. Для обработки множества клиентов нужно создавать много потоков, что ведёт к:
		Высокому потреблению памяти.
		Накладным расходам на переключение потоков.
		Низкая производительность при высокой нагрузке.
------------------------------------------------------------------------------------------------------------------------------------------------------
4) Шаблоны проектирования:
	*)Шаблон "Декоратор" (Decorator Pattern):
   		- Добавляет дополнительные функциональные возможности объекту, динамически расширяя его поведение.
   		- Позволяет добавлять новые функции без изменения основного класса.
	*)Шаблон "Итератор" (Iterator Pattern) используется к примеру в коллекциях:
   		- Предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутренней реализации.
   		- Упрощает обход элементов коллекции и предоставляет единый интерфейс для доступа к элементам различных коллекций.
	*)Шаблон "Фабричный метод" (Factory Method Pattern) используется к примеру в потоках данных:
   		- Определяет интерфейс для создания объекта, но делегирует сам процесс создания подклассам.
   		- Позволяет классу делегировать создание объектов подклассам, чтобы они могли выбирать, какой объект создавать.
	*)Шаблон "Команда" (Command Pattern) тот же bash:
   		- Инкапсулирует запрос в виде объекта, позволяя клиентам параметризовать клиентов с различными запросами.
   		- Позволяет отделить отправителя запроса от получателя, обеспечивая возможность сохранения и повторного выполнения запросов.
	*)Шаблон "Одиночка" (Singleton Pattern) статиеские поля и конструкторы:
   		- Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.
   		- Обеспечивает контролируемый доступ к одному объекту, который может использоваться в разных частях приложения.
	*)Шаблон "Стратегия" (Strategy Pattern) переорпеделение методов и тд, те же коллекции:
   		- Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
   		- Позволяет выбирать подходящий алгоритм во время выполнения программы.
	*)Шаблон "Адаптер" (Adapter Pattern) пример чтение дискет на совершенном компьютере с помощью спец устройства:
   		- Преобразует интерфейс одного класса в другой интерфейс, который ожидают клиенты.
   		- Позволяет классам работать вместе, которые ранее не могли этого делать из-за несовместимости интерфейсов.
	*)Шаблон "Фасад" (Facade Pattern) к примеру то же самое сетевое взаимодействие :
  		- Предоставляет унифицированный интерфейс для группы интерфейсов в подсистеме.
   		- Скрывает сложность подсистемы и облегчает взаимодействие с ней.
	*)Шаблон "Прокси" (Proxy Pattern) использование различных заглушек:
   		- Предоставляет заместитель или заполнитель для другого объекта, чтобы контролировать доступ к нему.
   		- Позволяет добавлять дополнительную логику до и после вызова метода объекта.
	*)Шаблон "Интерпретатор" (Interpretator Patern) используется к примеру в регулярках:
		- Используют, когда нужно обрабатывать лексические конструкции с определенными грамматическими правилами. Как пример — регулярные выражения
		- лексический процессор: анализирует выражение и создает из него токены. Токен - это объект, который хранит значение литерала и его тип;
		- обработчик токенов: строит абстрактное синтаксического дерево из токенов. Дерево строится в соответствии с приоритетом операций в выражении. Корень дерева - последняя операция в выражении;
		- сам интерпретатор: интерпретирует выражение пользователя. Если в выражении нет ошибок, обрабатывает его. В противном случае сообщает об ошибке.
	*)Шаблон "Приспособоленец" (FlyWeight Pattern) используется к примеру в для String:
		- структурный шаблон проектирования, который позволяет использовать разделяемые объекты сразу в нескольких контекстах. 
		- Используется преимущественно для оптимизации работы с памятью.
		- Стоит применять когда приложение использует большое количество однообразных объектов, из-за чего происходит выделение большого количества памяти
		- Стоить применять когда часть состояния объекта, которое является изменяемым, можно вынести во вне. Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.
----------------------------------------------------------------------------------------------------------------------------------------------
5) Конвееры 
	+)В Java пакет `java.util.stream` предоставляет функциональные возможности для работы с коллекциями и другими источниками данных 
	с использованием концепции конвейерной обработки данных (stream processing). 
	Конвейерная обработка данных позволяет эффективно и лаконично выполнять различные операции над данными, 
	такие как фильтрация, преобразование, агрегация и другие.
	Основными интерфейсами в пакете `java.util.stream` являются:
		1. `Stream<T>`: Представляет последовательность элементов типа `T` и предоставляет методы для выполнения операций над этими элементами.
		2. `IntStream`, `LongStream`, `DoubleStream`: Специализированные интерфейсы для работы с примитивными типами данных `int`, `long` и `double` соответственно.
	Конвейерная обработка данных с использованием `java.util.stream` обладает рядом преимуществ, таких как простота использования, 
	удобочитаемость кода и возможность эффективно использовать многопоточность для обработки данных параллельно. Это делает `java.util.stream` 
	мощным инструментом для работы с коллекциями и другими источниками данных в Java.
	+)Конвеер = источник + промежуточный операции + заверщающая операция
	+)Промежутоные операции:
		+) Возваращают и принимают поток
		+) Выполняются лениво, то есть только после заверщающей операции 
		
	+) Заверщающие операции:
		+) Возваращают результат либо побоное изменение 
		+) После выполнения поток перестает существовать
Немного про лямбы для конвееров 
Fucntion<t,r> - Принимает тип t, возвращает r
Predicate<t> - принимает тип t, возвращает boolean
Supplier<t> - принимает void, возвращает тип t
Consumer<t> - принимает t, возвращает void















	


		