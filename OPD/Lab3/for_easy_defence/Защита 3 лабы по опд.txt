------------------------------------------------------------------------
Виды адресации:
	Ответ на вопрос зачем нужны оба вида адресации. Относительаня для программ которые можно перемещать по памяти как угодго. Прямая для использования библиотек. 
	1) Прямая абсолютная \****\0\***********\
	2) Относительная \****\1\***\********\:
		Предусматривает взамидойсвтие с IP. !! Важно !! значение IP все еще увеличивается на 1 во время циклы выбора команды. 
		1. Прямая \****\1\110\********\:
			Обращается к адресу ячейки прибавляя к IP число из последний 8 битов команды ( может быть отрицательным ). 
			Теперь что происходит потактово:
				Цикл выборки адресса
				1) После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
				то есть к примеру из AEFE в СR получит FFFE  в BR) 
				2) В АЛУ суммируся BR и IP и пересылаются в DR.
				Цикл выборки операдна 
				3) СR пересылатеся  в СU ( cоntrol unit).
				4) ИЗ DR адрес пересылаестя в AR
				5) Ячейка памяти перегружается DR
				Дальше идет цикл исполнения как обычно 

		2. косвенная \****\1\000\********\:
			Обращается к адресу ячейки прибавляя к IP число из последний 8 битов команды ( может быть отрицательным ), после чего берет первые 11 битов из ячейки( адрес которой был  посчитан относительно IP) как адрес. 
			Поэтому все число может быть отрицатльеным но так как это адрес и берутся первые 11 битов все ОКЕЙ.
			Теперь что происходит потактово:
				Цикл выборки адресса
				1) После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
				то есть к примеру из AEFE в СR получит FFFE  в BR) 
				2) В АЛУ суммируются BR и IP и пересылаются сразу в AR.
				3) Ячейка со вторым адресов заргружается в DR.
				Цикл выборки операнда:
				4) СR пересылатеся  в СU ( cоntrol unit).
				5) DR пересылается в AR
				6) В DR заргужается уже последняя нужная ячейка памяти.
				Дальше идет цикл исполнения как обычно 
		!!!!!!!!!!!!!!!!! Если спросят зачем нужна автоинрементая и автодекрементная. Одна для прямого обхода массива, другая для обратного.
		3. косвенная авктоинрекментная \****\1\010\********\:
			Обращается к адресу ячейки прибавляя к IP число из последний 8 битов команды ( может быть отрицательным ), после чего берет первые 11 битов из ячейки( адрес которой был  посчитан относительно IP) как адрес , и потом увеличивает ее значение на 1.
			Поэтому все число может быть отрицатльеным но так как это адрес и берутся первые 11 битов все ОКЕЙ.
			Теперь что происходит потактово:
				Цикл выборки адресса
				1) После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
				то есть к примеру из AEFE в СR получит FFFE  в BR) 
				2) В АЛУ суммируются BR и IP и пересылаются сразу в AR.
				3) Ячейка со вторым адресов заргружается в DR.
				4) Адрес из DR проходит через АЛУ и инкрементируется ( +1) после чего записываетя обратно в DR.
				5) Адрес из DR записывает себя обратно в RAM.
				6) Адрес из DR проходит через АЛУ и декрементриутеся ( -1) после чего записываетя обратно в DR. 	
				Цикл выборки операнда:
				7) СR пересылатеся  в СU ( cоntrol unit).
				8) DR пересылается в AR
				9) В DR заргужается уже последняя нужная ячейка памяти.
				Дальше идет цикл исполнения как обычно
		4. косвенная авктодекрементная  \****\1\011\********\:
			Обращается к адресу ячейки прибавляя к IP число из последний 8 битов команды ( может быть отрицательным ), после чего берет первые 11 битов из ячейки( адрес которой был  посчитан относительно IP) как адрес , и потом уменьшает ее значение на 1.
			Поэтому все число может быть отрицатльеным но так как это адрес и берутся первые 11 битов все ОКЕЙ.
			Теперь что происходит потактово:
				Цикл выборки адресса
				1) После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
				то есть к примеру из AEFE в СR получит FFFE  в BR) 
				2) В АЛУ суммируются BR и IP и пересылаются сразу в AR.
				3) Ячейка со вторым адресов заргружается в DR.
				5) Адрес из DR проходит через АЛУ и декрементриутеся ( -1) после чего записываетя обратно в DR. 
				6) Адрес из DR записывает себя обратно в RAM.	
				Цикл выборки операнда:
				7) СR пересылатеся  в СU ( cоntrol unit).
				8) DR пересылается в AR
				9) В DR заргужается уже последняя нужная ячейка памяти.
				Дальше идет цикл исполнения как обычно  
	3) Прямая загрузка \****\1\111\********\: 
		Берет данные непосредсвтенно из последний 8 бит
		Цикл выборки адресса
		1) После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше,
		то есть к примеру из AEFE в СR получит FFFE  в BR) 
		2) Пересылает ВR в DR.
		Дальше идет цикл исполнения как обычно.
---------------------------------------------------------------------------------------------------------------------------------------
Как работают IF и jump(относительный) и loop:
	1) jump C\E\XX\: 
		Добавляет к IP число из последний 8 битов команды ( + 1 , опять же в цикле выбора команды  IP уже увеличили) 
		Разберем работу потактово:
			Цикл выборки адреса
			1. После загрузки команды в СR, последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
			то есть к примеру из AEFE в СR получит FFFE  в BR)
			2. В АЛУ суммируются BR и IP и пересылаются сразу в DR.
			Цикл выборки операнда:
			3. СR пересылатеся  в СU ( cоntrol unit).
			Цикл исполнения
			4. DR пересылается в IP
			Цилк прерывания 
	2) IF F\X\XX\:
		если условие ( зависит от значения битов с 8 по 11) выполнено добавляет IP число из последний 8 битов команды ( может быть отрицательным )
		Всегда перепригвает с цикла выборки команды сразу к исполнению
		Разберем работу потактово на примере BCS:
			Если условие не выполнено: в цикле исполнения ничего не происходит  после чего сразу  переход к циклу прерывания.
			Если выполнено:
				Цикл исполнения
				1.Последние 8 битов пересылаются  в ВR c расширеним 7 ( последений) бита(он копируется во все биты старше, 
				то есть к примеру из AEFE в СR получит FFFE  в BR)
				2. ВR суммируется с IP и пересылается  в IP.
				Цикл прерывания 
	3) loop 8\XXX\:
		1. Если счетчик больше 1:
			Цикл выборки операнда 
			......
			1) В DR счеткчик цикла  
			Цикл исполнения
			2) DR декрментируется  и пересылается  сам в себя.
			3) DR пересылается обратно в RAM и одновременно в ВR через АЛУ с декрементом. 
			4) BR пересылается в СU ( cоntrol unit).
			5) Цикл прерывания 
		2. Если счетчик меньше либо равен 1:
			Цикл выборки адреса 
			......
			1) В DR счеткчик цикла  
			Цикл исполнения
			2) DR декрментируется  и пересылается  сам в себя.
			3) DR пересылается обратно в RAM и одновременно в ВR через АЛУ с декрементом. 
			4) BR пересылается в СU ( cоntrol unit).
			5) IP проходит через АЛУ, инкрементируется  и записыватеся обратно. ( В сумме IP += 2 ) 
			6) Цикл прерывания 
	Если зададут вопрос зачем нужно еще раз декременитить в ВR. Прямо этого нигде не говорится но по-моему это чтобы облегчить проверку, то есть переход происходит если DR <= 0, 
	а если сделать декремент то ВR < 0 всегда.
	!!!! Если зададут вопрос что будет если сделать прямую загрузку для loop. После декрмента DR  запишется обратно в RAM на место команды. 
	Как и почему это происходит? После цикла выборки команды в AR остался адрес самой команды loop, а команда записывает DR после декрмента обратно в RAM именно по этому адресу.
---------------------------------------------------------------------------------------------------------------------------------------
Установка флагов после команд 
Мнемоника NZVC  "-" - не изменяется, "*" - по результатам, "0" - всегда равно 0 
NOP - - - -
Loop - - - - 
Jump - - - - 
CLA * * 0 - 
NOT * * 0 - 
LD * * 0 - 
SXTB * * 0 - 
SWAB * * 0 - 
OR * * 0 - 
ROL * * * * 
ASR * * * * 
ADD * * * * 
SUB * * * * 
CMP * * * * 
CLC - - - 0
CMC - - - *


		
			

