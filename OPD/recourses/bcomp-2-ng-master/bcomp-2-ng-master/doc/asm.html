<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Ассемблер БЭВМ</title>
  <!-- $Id$ -->
</head>
<body>

<h1 id="a1">Ассемблер <a href="index.html">БЭВМ</a></h1>

<h3 id="a1">Содержание</h3>
<ol>
<li><a href="#a2">Синтаксис</a></li>
<li><a href="#a3">Описание директив</a></li>
<li><a href="#a4">Метки</a></li>
<li><a href="#a5">Специальные метки</a></li>
<li><a href="#a6">Комментарии</a></li>
<li><a href="#a7">Ограничения и известные проблемы</a></li>
<li><a href="#a8">Примеры использования</a></li>
</ol>

<h3 id="a2">Синтаксис</h3>
<table border="1">
<tr>
  <td align="center"><b>Назначение</b></td>
  <td align="center"><b>Синтаксис</b></td>
  <td align="center"><b>Пример использования</b></td>
</tr>
<tr>
  <td>Управление размещением в памяти</td>
  <td><code>ORG адрес</code></td>
  <td><code>ORG 10</code></td>
</tr>
<tr>
  <td rowspan=2>Константы и переменные</td>
  <td><code>[метка:] WORD ЗНАЧЕНИЕ [, ЗНАЧЕНИЕ ...]</code></td>
  <td><code>XYZ: WORD ?, DEAD, BEEF</code></td>
</tr>
<tr>
  <td><code>[метка:] WORD количество DUP (значение)</code></td>
  <td><code>ARRAY: WORD 6 DUP (?)</code></td>
</tr>
<tr>
  <td>Адресная команда с прямой адресацией</td>
  <td><code>[метка:] МНЕМОНИКА АРГУМЕНТ</code></td>
  <td><code>MOV R</code></td>
</tr>
<tr>
  <td>Адресная команда с косвенной адресацией</td>
  <td><code>[метка:] МНЕМОНИКА (АРГУМЕНТ)</code></td>
  <td><code>ADD (K)</code></td>
</tr>
<tr>
  <td>Безадресная команда</td>
  <td><code>[метка:] МНЕМОНИКА</code></td>
  <td><code>BEGIN: CLA</code></td>
</tr>
<tr>
  <td>Команда ввода-вывода</td>
  <td><code>[метка:] МНЕМОНИКА АДРЕСВУ</code></td>
  <td><code>OUT 3</code></td>
</tr>
</table>

<p>Метки, команды, их аргументы и т.п. должны быть отделены друг от друга пробелом или символом табуляции.

<h3 id="a3">Описание директив</h3>
<ol>
<li><code>ORG address</code> - указывает компилятору, что следующее значение необходимо располагать по указанному адресу. Похожа на пультовую команду "Ввод адреса". Обычно данную директиву достаточно использовать один раз в начале программы.</li>
<li><code>WORD</code> - ввод констант и резервирование памяти. Может быть указано одно или более значений. Если в качестве значения указан вопросительный знак, то соответствующая ячейка памяти остаётся неинициализированной. Если указанное значение не удалось распознать как шестнадцатеричное число, то в качестве значения будет использован адрес метки с указанным именем. При использовании в синтаксисе <code>WORD количество DUP (значение)</code> соответствующее значение будет продублировано указанное количество раз.</li>
</ol>

<h3 id="a4">Метки</h3>
Метки являются ссылками на соответствующие ячейки памяти. Могут использоваться в качестве аргумента для адресных команд и для инициализации других ячеек адресом, на которую ссылается метка. В имени метки могут использоваться любые символы, однако, в связи с особенностями обработки констант, не рекомендуется использовать имена меток, которые могут быть восприняты как шестнадцатеричное число.

<h3 id="a5">Специальные метки</h3>
<ol>
<li><code>BEGIN</code> - указывает компилятору на первую выполняемую команду программы. Должна быть указана в любой программе.</li>
<li><code>R</code> - указывает на ячейку, в которой будет располагаться результат. После успешной компиляции, если в программе была обнаружена метка R, <a href="cli.html">консольная версия БЭВМ</a> выведет адрес соответствующей ячейки памяти.</li>
</ol>

<h3 id="a6">Комментарии</h3>
Любой текст в строке после символа <code>;</code> или <code>#</code> считается комментарием.

<h3 id="a7">Ограничения и известные проблемы</h3>
<ol>
<li>Все вводимые значения воспринимаются в шестнадцатеричной системе, и диапазон допустимых значений не проверяется. Следует обратить внимание, что, например, значения <code>8000</code> и <code>-8000</code> будут интерпретированы как одно и тоже число.</li>
<li>Аргументы адресных команд воспринимаются как имя метки <b>только</b> если не являются шестнадцатеричным числом.</li>
<li>Обработка и диагностика ошибок находятся в зачаточном состоянии.</li>
<li>При использовании директивы <code>ORG</code> компилятор не отслеживает возможное перекрытие частей программы. Приведённый ниже код скомпилируется без ошибок, но в памяти БЭВМ окажется некорректная программа.</li>
<pre>
ORG	10
BEGIN:	CLA
	ADD	X
	ADD	Y
	MOV	R
	HLT

ORG	12
X:	WORD	DEAD
Y:	WORD	BEEF
R:	WORD	?
</pre>
</ol>

<h3 id="a8">Примеры использования</h3>
<h4>Сложение двух чисел</h4>
<pre>
ORG	010
BEGIN:	CLA
	ADD	X
	ADD	Y
	MOV	R
	HLT

ORG	018
R:	WORD	?
X:	WORD	DEAD
Y:	WORD	BEEF
</pre>

<h4>Подсчёт количества неотрицательных элементов в массиве</h4>

<h5>Решение 1. Старый стиль</h5>
<pre>
ORG	00F
	WORD	0020
BEGIN:	WORD	F200,480F,A017,F200,401B,F800,301B,001A,C010,F000,FFFA,0000
ORG	020
	WORD	0001,FFFF,0002,FFFE,0003,FFFD
</pre>
<h6>Преимущества:</h6>
<ol>
<li>Работает.</li>
<li>Ввод программы максимально приближен к обычной работе с <a href="index.html">БЭВМ</a>.</li>
</ol>
<h6>Недостатки:</h6>
<ol>
<li>Собственно возможности ассемблера не используются.</li>
<li>Из текста программы не понятно где расположены команды, а где данные и результат.</li>
</ol>

<h5>Решение 2. Студенческое</h5>
<pre>
ORG	00F
	WORD	0020

BEGIN:	CLA
	ADD	(00F)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	01A
	BR	BEGIN
	HLT

	WORD	-6
R:	WORD	?

ORG	020
X:	WORD	0001, FFFF, 0002, FFFE, 0003, FFFD
</pre>
<h6>Преимущества:</h6>
<ol>
<li>Тоже работает.</li>
</ol>
<h6>Недостатки:</h6>
<ol>
<li>Из поля зрения выпадают исходные данные хранящие адрес первого элемента массива и их количество.</li>
<li>При повторном запуске программы с новыми данными результат может быть некорректным.</li>
</ol>

<h5>Решение 3. Правильное</h5>
<pre>
ORG	00F
K:	WORD	?	; Адрес первого элемента массива

BEGIN:	CLA
	MOV	R
	ADD	(K)
	BMI	SKIP
	CLA
	ADD	R
	INC
	MOV	R
SKIP:	ISZ	N
	BR	BEGIN
	HLT

N:	WORD	?	; Количество элементов массива
R:	WORD	?	; Результат

ORG	020
X:	WORD	6 DUP (?)	; Элементы массива
</pre>
<h6>Преимущества:</h6>
<ol>
<li>Видны все исходные данные, используемые программой.</li>
<li>При повторном запуске программы с новыми исходными данными результат будет корректным.</li>
</ol>
<h6>Недостатки:</h6>
<ol>
<li>Перед запуском программы пользователь должен самостоятельно ввести все исходные данные.</li>
<li>Пользователь может ошибочно посчитать, что программа может работать только с массивом из 6 элементов.</li>
</ol>

<h4>Обработка прерываний</h4>
<h5>Требования</h5>
<ol>
<li>В основной программе должно циклически сдвигаться содержимое ячейки R, всегда содержащее один единичный бит.</li>
<li>Раз в десять секунд должно увеличиваться содержимое ячейки T.</li>
<li>При запросе от ВУ1 выводить на него значение ячейки X.</li>
<li>При запросе от ВУ2 сохранять введённое в РД ВУ2 значение в ячейку X.</li>
<li>При запросе от ВУ3 обменивать местами значение его РД и ячейки X.</li>
<li>Обмен с ВУ осуществлять в режиме прерывания.</li>
</ol>
<h5>Решение</h5>
<pre>
ORG	000
RET:	WORD	?
	BR	INT

ORG	010
BEGIN:	CLA
	MOV	T
	ADD	CONST
	OUT	0
	EI
	CLA
	INC
LOOP:	ROR
	BCS	LOOP
	MOV	R
	BR	LOOP

ORG	01C
CONST:	WORD	64
X:	WORD	0
T:	WORD	?
R:	WORD	?

INT:	MOV	STOR_A
	ROL
	MOV	STOR_C
	TSF	0
	BR	IO1
	CLF	0
	ISZ	T
	NOP
IO1:	TSF	1
	BR	IO2
	CLA
	ADD	X
	OUT	1
	CLF	1
IO2:	TSF	2
	BR	IO3
	CLA
	IN	2
	CLF	2
	MOV	X
IO3:	TSF	3
	BR	END
	CLA
	IN	3
	MOV	TMP
	CLA
	ADD	X
	OUT	3
	CLF	3
	CLA
	ADD	TMP
	MOV	X
END:	CLA
	ADD	STOR_C
	ROR
	CLA
	CMA
	AND	STOR_A
	EI
	BR	(RET)
TMP:	WORD	?
STOR_A:	WORD	?
STOR_C:	WORD	?
</pre>
При выполнении данной программы в <a href="gui.html">графической реализации эмулятора</a> рекомендуется <a href="gui.html#a3">уменьшить задержку между тактами</a>.
</body></html>
