Функции:
	Выполняют произвольный список операторов SQL
	и возваращают результат последнего запроса в списке.
	Возвращаемое значение:
		1)Если последий запрос ничего не возвращает - NULL
		2)Если возвращает не множество то первую строку результата последнего запроса
		3)Если возвращает множество (тогда нужно указать возвращаемым типом SETOF тип_данных 
		либо объявить функцию с указанием returns table( столбцы). 
		То функция вернет все строки результата последнего запроса.
		4)Если тип данных объявленый в функции и реально возвращаемый не совпадают, то 
		SQL автоматически приведет один к другому.
		5)Составные значения так же можно указавать как возвращаемый тип. Для этого кроме select можно использовать команду ROW.
		6)Можно задавать функции с выходным параметром, не обозначяя его в RETURNS, тогда 
		нужно там же где и аргументы указывать выходные  и входные параметры с помощью слов IN и OUT.
		ПРИМЕР:
		CREATE TYPE sum_prod AS (sum int, product int);
		CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
			AS 'SELECT $1 + $2, $1 * $2'
		LANGUAGE SQL;
		Одно и тоже с:
		CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
			AS 'SELECT x + y, x * y'
		LANGUAGE SQL;
		7) Некоторые функции могут пораждать таблицы. Если функция возвращает составной тип с помощью SELECT
		  и используется  после FROM в запросе, то вернется не одна строке, а вся таблица.
		8)Функция может возвращать таблицу если указать ее как возвращаемый тип данных. Тогда нужно после слова table в скобках указывать атрибуты возвращаемой таблицы.
		Пример:
		CREATE FUNCTION sum_n_product_with_tab (x int)
			RETURNS TABLE(sum int, product int) AS $$
    		SELECT $1 + tab.y, $1 * tab.y FROM tab;
		$$ LANGUAGE SQL;
	Тело:
		1)Представляет список SQL операторов, разделяемых ;(после полсденего может отсутсововать)
		2) В конце (если не указан тип void как возвращаемый) должен быть оператор select,
		либо команда c указанием returning
		3)Команды для упраления тразакциями запращены 
		4)Тело должно быть указано как строковая константа.
	Аргументы:
		1)Чтобы испозьвать имя аргумента, необходимо указать его при объявлении функции.
		(если оно совпадает с именем какого-то столбца, то столбец будет иметь приоритет)
		2)Вместо имен можно использовать, нумеризацию, тогда имена аргументов не указываются,а остаются только
		типы данных. Для обращения нужно использовать запись $n. Это будет работать даже у аргумента есть имя.
		3)Аргументы не могут использоваться как индентификаторы, то есть INSERT INTO $1 VALUES (42); так написать нельзя.
		4)Если функция принимает составное значение то разницы между f(emp) и f(emp*) нет. (emp - таблица)
		5)Можно создавать составное значение на лету используюя команду ROW. f( ROW( "типа данных для emp"))
		6)Можно задавть функции с аргументами (обязательно одного типа данных) переменной длины, для этого необходимо использовать ключевое слово VARIADIC.
		ПРИМЕР:
		CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
   			SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
		$$ LANGUAGE SQL;
		SELECT mleast(10, -1, 5, 4.4);
		7)Можно задавать аргументы функций по умолчанию используя ключевое слово default либо знак равно. Тогда этот аргумент необязятелен при вызове функциию
	Плюшки особенности:
		1) SELECT f()  и очевидно SELECT * FROM f() почти одно и тоже но нет.
		2) Если задавть функцию выходным параметром то удаляя ее можно как указывать выходные параметры так и нет,
		Так как SQL определяет сигнатуру функции по входныем параметрам.
		3) Можно перегружать как и в java.	
		4) Можно указывать стоимость выполнения для оптимизатора.
		5) Можно писать на разных языках.
		6) Для экранирвоания кавычек внутри лучше тело заключать в $$.
	Категории изменчивости:
		1) Volatiel:  может делать всё, что угодно, в том числе, 
		модифицировать базу данных. Она может возвращать различные результаты при нескольких
		 вызовах с одинаковыми аргументами. Оптимизатор не делает никаких предположений о
		поведении таких функций. В запросе, использующем изменчивую функцию, 
		она будет вычисляться заново для каждой строки, когда потребуется её результат.
		2) Stable: не может модифицировать базу данных и гарантированно возвращает одинаковый результат, получая одинаковые аргументы, 
		для всех строк в одном операторе. Эта характеристика позволяет оптимизатору заменить множество вызовов этой функции одним.
		3) Immutable: не может модифицировать базу данных и гарантированно всегда возвращает одинаковые результаты для одних и тех же аргументов.
Процедуры:
	Процедура — объект базы данных, подобный функции, но имеющий следующие отличия:
	1) Очевидно объявляется с помощтю create procedure
	2) Не возвращает значение
	3) Процедуры не могут вызываться как часть запроса или команды DML. 
	4) Для их вызова существует специальная команда call
	5) Может использовать транзакции.
	6) Можно создавать анонимные процедуры без имени, которые будут выполняться сразу.
Триггеры:
	+)Триггер является указанием, что база данных должна автоматически выполнить заданную функцию, всякий раз когда выполнен определённый тип операции. 
	+)Триггеры можно использовать с таблицами и представлениями.
	+)Для обычных и сторонних таблиц можно определять триггеры, которые будут срабатывать до или после любой из команд INSERT, UPDATE или DELETE; 
	либо один раз для каждой модифицируемой строки, либо один раз для оператора SQL. 
	+)Также триггеры могут срабатывать для операторов TRUNCATE. Если происходит событие триггера, для обработки этого события в установленный момент времени вызывается функция триггера.
	+)Для представлений триггеры могут быть определены для выполнения вместо операций INSERT, UPDATE и DELETE. Такие триггеры INSTEAD OF вызываются единожды для каждой строки, 
	которая должна быть изменена в этом представлении.
	+)Триггерная функция должна быть создана до триггера. Она должна быть объявлена без аргументов и возвращать тип trigger. 
	(Триггерная функция получает данные на вход посредством специально переданной структуры TriggerData, а не в форме обычных аргументов.)
	+)После создания триггерной функции создаётся триггер с помощью CREATE TRIGGER. Одна и та же триггерная функция может быть использована для нескольких триггеров.
	+)PostgreSQL предлагает как построчные, так и операторные триггеры.  Можно привести аналогию с коррелированными и некоррелированными подзапросами.
	+)Триггерные функции, вызываемые триггерами операторов, должны всегда возвращать NULL.
	+)Триггерные функции, вызываемые триггерами строк, могут вернуть строку таблицы.
	+)У триггера уровня строки, срабатывающего до операции, есть следующий выбор:
	Можно вернуть NULL, чтобы пропустить операцию для текущей строки. Это указывает исполнителю запросов, что не нужно выполнять операцию со 
	строкой вызвавшей триггер (вставку, изменение или удаление конкретной строки в таблице).
	Возвращаемая строка для триггеров INSERT или UPDATE будет именно той, которая будет вставлена или обновлена в таблице. 
	Это позволяет триггерной функции изменять вставляемую или обновляемую строку.
	+)Возвращаемое значение игнорируется для триггеров уровня строки, вызываемых после операции, поэтому они могут возвращать NULL.
	+)В случае построчного триггера триггерная функция вызывается один раз для каждой строки, затронутой оператором, запустившим триггер. 
	+)Операторный же триггер, напротив,  вызывается только один раз при выполнении соответствующего оператора, независимо от количества строк, которые он затрагивает. 
	В частности оператор, который не затрагивает никаких строк, всё равно приведёт к срабатыванию операторного триггера. 
	+)Триггеры также классифицируются в соответствии с тем, срабатывают ли они до, после или вместо операции. Они называются триггерами BEFORE, AFTER и INSTEAD OF, соответственно.
	+)Триггеры BEFORE срабатывают до того, как оператор начинает делать что-либо, тогда как триггеры AFTER срабатывают в самом конце работы оператора. 
	Эти типы триггеров могут быть определены для таблиц, представлений
	+)Триггеры INSTEAD OF могут определяться только для представлений и только на уровне строк: они срабатывают для каждой строки сразу после того 
	как строка представления идентифицирована как подлежащая обработке. 
	+)Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они будут вызываться в алфавитном порядке по имени триггера. 
	+)В определении триггера можно указать логическое условие WHEN, которое будет проверяться, чтобы посмотреть, нужно ли запускать триггер.
	Триггеры при изменении данных:
		1) Объявляется как функция без аргументов и возвращаемых типом данных тригер. 
		Заметьте, что эта функция должна объявляться без аргументов, даже если ожидается, что она будет получать аргументы, 
		заданные в команде CREATE TRIGGER — такие аргументы передаются через TG_ARGV
		2) Триггерная функция должна вернуть либо NULL, либо запись/строку, соответствующую структуре таблице, для которой сработал триггер.
		3) При выполнении тригера автоматически создаются несколько переменных вот ряд самых выжных и нужных:
			1) New - содержит новую строку которая будет подстанавливаться если это требует триггер. Может иметь значение null для некоторых триггеров.
			2) Old - содержит старую строку.Может иметь значение null для некоторых тригг
			3) TG_NAME - имя стработавшего тригера
			4) TG_OP - содержит тип триггера
			5) TG_WHEN - содрежит момент исполнения триггера ( before after instade of)
			6) TG_TABLE_NAME - имя таблицы для которой стработал триггер
			7) TG_ARGV[] - аргумента триггера в виде массива text 
		4) Если триггер с уровнем before возвращает null, то все дальнешие дествия со строкой прекращаются.сли возвращается не NULL, то дальнейшая обработка продолжается именно с этой строкой
		5) Триггеры INSTEAD OF могут возвращать NULL,  чтобы показать, что они не выполняли никаких изменений, так что обработку этой строки можно не продолжать
		6) Для операций INSERT и UPDATE возвращаемым значением должно быть NEW, которое триггерная функция может модифицировать для поддержки предложений INSERT RETURNING и UPDATE RETURNING 
		7) Для операций DELETE возвращаемым значением должно быть OLD.
		8) Возвращаемое значение для строчного триггера AFTER  всегда игнорируется. Это может быть и NULL.
	Триггеры событий:
		1) Срабатывают на DDL
		2) Процедура, которая вызывается как событийный триггер, должна объявляться без аргументов. Типом возвращаемого значения должен быть event_trigger
		3) ddl_command_start — перед началом работы DDL команды;
 		4) ddl_command_end — после окончания работы DDL-команды;
 		5) table_rewrite — перед ALTER TABLE;
		6)  sql_drop — перед ddl_command_end при удалении объектов